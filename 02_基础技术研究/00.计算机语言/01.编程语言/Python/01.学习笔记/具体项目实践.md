---
title: 具体项目实践
author: 凌杰
date: 2024-06-20
tags: 程序设计
categories: 编程语言
---

> [!NOTE] 笔记说明
>
> 在阅读完了《[[基础语法学习|Python 学习笔记：基础语法学习]]》之后，相信读者已经初步体验到了 Python 社区所推崇的“优雅、明确、简单”的编码风格。在接下来的这篇笔记中，我们将会基于这些原则，逐步从脚本式代码过渡到结构清晰、依赖可控、可分发的 Python 项目。本篇将聚焦于：
>
> - 介绍如何遵循 PEP 规范（例如 PEP 8）来构建 Python 项目；
> - 介绍如何基于虚拟环境来安装并管理项目依赖（基于 uv 和 pip）；
> - 介绍将项目打包为可执行文件或可分发的扩展包（基于 uv）；

## PEP 规范与项目结构设计

在我开始学习 Python 的那个年代，这门编程语言在大多数使用场景下仍然被当作一种用于编写单一脚本文件的工具，而非用于构建完整项目的开发语言。换言之，那时候所谓的 Python 程序往往都只是若干独立脚本的集合，并不构成严格意义上的“项目”，自然也谈不上系统化的项目结构设计。这并非偶然。Guido van Rossum 在最初设计 Python 时，其核心目标之一，正是用一种语法简洁、可读性良好的高级语言，来替代 Unix Shell 以完成常见的系统管理与自动化任务。在这样的设计初衷下，Python 更强调“快速完成一件事”，而非长期维护的大规模工程组织。

然而，随着 Python 在近十余年间在科学计算、Web 开发、数据分析以及工程自动化等应用领域的蓬勃发展，人们对它的使用方式发生了根本性的变化。越来越多的开发者开始使用 Python 来构建功能复杂、生命周期较长的系统，这也使得代码的组织方式、模块边界以及项目结构设计逐渐成为一个无法回避的问题。因此，在讨论具体项目的实践之前，我们需要先解决一个经常被初学者忽视、但在真实工程中极其关键的问题：**代码应该如何被组织，以及应当遵循怎样的规范来书写**。

在如今的 Python 社区中，人们针对工程化的项目结构设计已经形成了一整套的可遵循的规范文档，这些文档被统称为 **Python Enhancement Proposals，简称 PEP**。当然，PEP 中的大部分内容是用于规范语言设计或解释器实现的，而我们在这里要讨论的是面向项目工程化实践的那一小部分，其目的是在项目结构设计方面建立起统一的约定，以便显著降低项目被理解的成本。这可以使开发者之间无需反复适应不同的代码组织习惯，从而把注意力集中在**业务逻辑本身**。下面，就让我们以当前主流的 PEP 8 为例，来具体介绍一下 Python 项目结构设计的基本原则。

### 从脚本到项目：结构上的转变

许多初学者在学习 Python 时，习惯于将所有代码写在单个 `.py` 文件中。这在学习阶段完全没有问题，但一旦进入真实而具体的项目，就会迅速暴露出可维护性上的瓶颈。而如果我们想要将自己的代码项目化，首先要做的就是安排好项目的目录结构。一个最基础、也是最常见的 Python 项目可以通过我们之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》一节中提到的 `uv` 项目管理工具来生成，其具体步骤如下：

1. 在当前计算机的任意位置创建一个名为 `python_demo` 的目录，并使用命令行终端程序打开该目录。

2. 在命令行终端中执行 `uv init` 命令，这样就得到了一个初步符合 PEP 8 规范的 Python 项目，其项目结构通常如下所示：

    ```text
    python_demo
    ├── .python-version # 用于指定 Python 解释器版本号的文件
    ├── pyproject.toml  # 项目配置文件，用于填写一些项目元信息
    ├── main.py         # 项目入口代码，现在是一个 Hello, World! 程序
    └── README.md       # 项目说明文件，用于填写项目简介
    ```

3. 虽然上述项目结构已经足以应对一些小型的开发需求了，但如果我们想让它更贴近当前社区普遍认可的 PEP 实践，还需要进一步调整。为此，我们需要继续在 ``python_demo` 目录下分别创建 `src` 和 `tests` 这两个子目录，并将之前位于项目根目录下的 `main.py` 文件移动到 `src` 目录中。调整后的项目结构如下所示：

    ```text
    python_demo
    ├── .python-version        # 用于指定 Python 解释器版本号的文件
    ├── pyproject.toml         # 项目配置文件，用于填写一些项目元信息
    ├── README.md              # 项目说明文件，用于填写项目简介
    ├── src                    # 用于存放项目代码的目录
    │   └── python_demo        # 用于存放模块代码的子目录
    │       ├── __init__.py    # 用于声明当前子目录为模块的空文件
    │       └── main.py        # 模块入口代码，现在是一个 Hello, World! 程序
    └── tests                  # 用于存放测试代码的目录
    ```

    上述项目结构体现了几个重要的工程原则：

    - **项目元信息与代码分离**：项目配置文件（如 `pyproject.toml`）位于根目录，而项目的实际源代码被集中放置在 `src` 目录中。
    - **项目结构的模块化**：通过在特定的子目录中放置 `__init__.py` 文件，将其声明为模块，从而使得 Python 解释器能够正确识别该目录。
    - **测试与实现分离**：测试代码位于独立的 `tests` 目录中，避免与业务代码混杂。

当然，这里需要再次强调的是：PEP 8 中提出的这种项目结构设计规范不是强制标准，并不妨碍开发者们在组织项目方面的个性化发挥，但在生产环境中，它已经成为当前 Python 社区中被广泛认可的“最佳实践”之一。

### 为什么推荐使用 `src` 目录结构

读者可能会觉得有点疑惑，为什么我们需要将程序的实现代码放置一个独立 `src` 目录中？这种做法在项目结构设计上的现实意义是什么？简而言之，它的直接目的是建立一个独立的、结构化的代码组织机制，以便有效地避免以下问题：

- 意外导入当前目录下的同名模块；
- 在未正确安装项目时，代码“看似可运行但并不规范”；
- 部署或打包阶段出现路径相关的隐蔽错误。

换句话说就是，设置 `src` 目录可以迫使我们**以“已安装包”的方式来使用自己的项目代码**，这与真实的部署和分发场景高度一致。另外，在拆分模块时，我们也要注意不要一味地“越细越好”，应遵循以下几个简单但实用的原则：

- 每个模块只关注一类明确职责；
- 模块名应反映其用途，而不是实现细节；
- 避免在模块之间形成循环依赖；
- 对外暴露的接口应尽量稳定，内部实现可以自由调整。

总而言之，如果读者发现某个文件不断膨胀、同时承担多种职责时，往往就意味着它已经到了需要拆分的时刻。

在这一节中，我们并没有编写任何“功能性代码”，但所做的工作却直接决定了项目未来的可维护性上限。通过遵循 PEP 规范，并在一开始就建立清晰的项目结构，我们为后续的依赖管理、测试、打包与分发打下了坚实基础。在下一节中，我们将从工程实践的角度出发，介绍如何基于虚拟环境来**安装并管理项目依赖**，并说明为什么在真实项目中，依赖管理应当被视为项目设计的一部分，而不是事后补救的步骤。

## 项目依赖的安装与管理

在完成了上述项目结构设计的基本工作之后，我们接下来要解决的是另一个在具体项目实践中不可回避的问题：**如何安装、隔离并稳定地管理项目依赖**。对于 Python 项目而言，依赖管理不仅是要“能将项目所依赖的扩展包装上”，更重要的是要实现以下几个更本质的目标：

- 确保不同项目之间所依赖的扩展包互不干扰；
- 项目在不同机器、不同时间点上具有一致的运行环境；
- 项目所依赖的这些扩展包在版本上是可追溯、可复现的。

为了实现上述目标，Python 社区逐步形成了一套围绕虚拟环境（Virtual Environment）展开的通用实践。接下来，就让我们继续以 uv 这款项目管理工具为例，介绍现代 Python 项目中推荐的依赖管理方式。

### 为什么推荐使用 uv 来管理项目依赖

正如我之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》中所介绍的，在没有虚拟环境的情况下，Python 的第三方扩展通常会被安装到系统级解释器的 `site-packages` 目录中。这种做法在早期看似方便，但很快就会带来严重问题：

- 不同项目对同一依赖的版本要求可能冲突；
- 升级或卸载某个库可能意外破坏其他项目；
- 很难准确还原某个历史版本项目的运行环境。

虚拟环境的核心作用，就是为**每个项目提供一个相互隔离的 Python 运行时环境**，使解释器、第三方库以及相关工具只对当前项目可见。在具体项目的实践中，可以将虚拟环境理解为“项目的运行时沙箱”。但是，如果我们使用 Python 官方提供的解决方案。即先用`venv` 来创建虚拟环境，然后再用 pip 工具的`pip install`命令来安装依赖，那么随着项目的规模越来越大，我们很快就会遇到以下这些棘手的问题：

- 项目所依赖的扩展包在版本上并未被明确锁定；
- 不同机器上解析出的依赖树可能不完全一致；
- 安装速度在项目依赖的扩展包较多时会明显下降。

为了解决这些问题，在基于 uv 这类现代化的项目管理工具所提出的解决方案中，pip 通常不再单独使用，而是作为底层安装器，配合更高层的依赖管理工具共同完成工作。总而言之，我们可以将 uv 理解为一个集成了依赖解析、安装、锁文件生成等功能的工具链组件，它使得依赖管理过程更加高效、稳定。并且，它在设计上吸收了多种现有方案的优点，并试图以更统一的方式解决以下问题：

- 依赖解析速度慢；
- 环境复现不稳定；
- 工具链分散、职责重叠。

在 uv 的工作流中，依赖管理通常围绕 `pyproject.toml` 文件展开，这也是当前 Python 社区推荐的项目元数据与配置入口。

一个最简化的依赖声明示例如下：

```toml
[project]
name = "python-demo"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "numpy>=1.26,<2.0",
]
```

在激活虚拟环境后，通过 uv 安装依赖：

```bash
uv pip install
```

uv 会基于当前项目的配置文件解析依赖关系，并调用 pip 完成实际安装过程，同时尽可能保证解析结果的确定性与一致性。

### 锁定依赖版本的重要性

在真实项目中，**“能安装”并不等于“可复现”**。

为了确保项目在不同时间、不同环境中的行为一致，依赖版本应当被明确锁定，而不是无限制地跟随最新版本更新。uv 在这方面提供了对锁文件的原生支持，使依赖状态成为项目的一部分，而不是隐含在某台机器中。

从工程角度来看，锁定依赖版本意味着：

* 构建过程是可重复的；
* 线上问题更容易回溯；
* 协作成员的环境更加一致。

在这一节中，我们围绕虚拟环境，系统性地介绍了 Python 项目中依赖管理的基本思路：

* 虚拟环境是项目级隔离的基础设施；
* pip 负责执行安装，但并不擅长整体依赖管理；
* uv 提供了更现代、更稳定的依赖解析与管理能力；
* 依赖版本应当被视为项目设计的一部分，而非临时决策。

在下一节中，我们将进一步讨论：**如何将一个已经结构清晰、依赖稳定的 Python 项目，打包为可执行文件或可分发的扩展包**，并说明这些能力在实际工程和发布场景中的意义。

## 项目的打包与分发

当一个 Python 项目完成了合理的目录结构设计，并且其依赖关系已经通过虚拟环境与锁文件得到了稳定管理之后，我们就可以开始考虑一个更偏向“交付”的问题：**如何将项目打包并分发给他人使用**。

在工程语境中，“分发”并不只意味着把代码拷贝给别人，而通常包含以下几种常见目标：

* 作为 **Python 扩展包** 分发，供其他项目通过依赖方式引入；
* 打包为 **可执行命令行工具**，供用户直接运行；
* 在某些场景下，进一步打包为 **独立可执行文件**，以减少运行环境依赖。

本节将以 **uv** 所遵循的现代 Python 打包规范为主线，介绍当前推荐的项目打包与分发方式。

### Python 项目为什么需要“标准化打包”

在早期的 Python 项目中，打包方式高度分散：

* 有的项目依赖 `setup.py`；
* 有的项目通过自定义脚本发布；
* 有的项目甚至完全没有明确的打包入口。

这种做法在项目规模较小时尚可接受，但在多人协作、持续集成或长期维护场景中，会迅速暴露问题：

* 构建流程不可复现；
* 工具链难以统一；
* 新成员难以上手。

为了解决这些问题，Python 社区逐步形成了一套围绕 **PEP 517 / PEP 518 / PEP 621** 的现代打包规范，其核心思想是：

> **将项目的元数据、构建方式与依赖声明集中到一个统一的配置入口中。**

这个入口，就是 `pyproject.toml`。

### pyproject.toml：现代 Python 项目的核心配置文件

在前面的章节中，我们已经接触过 `pyproject.toml` 在依赖管理中的作用。事实上，它同时也是项目打包与分发的核心配置文件。

一个用于打包的最小可用示例如下：

```toml
[project]
name = "hello-python"
version = "0.1.0"
description = "A minimal Python project example"
readme = "README.md"
requires-python = ">=3.10"

dependencies = [
    "numpy>=1.26,<2.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

在这个配置中：

* `[project]` 部分定义了项目的**对外元数据**；
* `[build-system]` 部分定义了**如何构建该项目**；
* 具体的构建实现被委托给一个后端工具（如 `hatchling`）。

uv 并不强制你使用某一个构建后端，但它能够很好地与主流后端协同工作，从而简化整体流程。

### 将项目打包为可分发的 Python 扩展包

在完成配置之后，我们就可以将项目构建为 Python 社区通用的分发格式，例如：

* `wheel`（`.whl` 文件）
* 源码分发包（`.tar.gz`）

使用 uv 构建项目的流程非常直接：

```bash
uv build
```

执行该命令后，uv 会：

1. 读取 `pyproject.toml`；
2. 调用指定的构建后端；
3. 在项目根目录下生成 `dist/` 目录；
4. 将构建产物输出到其中。

这些构建产物可以被：

* 上传至私有或公共包仓库；
* 通过 pip / uv 安装；
* 作为其他项目的依赖直接引用。

### 定义命令行入口点（CLI）

除了作为库被引用之外，许多 Python 项目还需要以**命令行工具**的形式被使用。

在现代打包规范中，CLI 的定义同样通过 `pyproject.toml` 完成。例如：

```toml
[project.scripts]
hello-python = "hello_python.main:main"
```

这段配置的含义是：

* 安装该项目后，会生成一个名为 `hello-python` 的命令；
* 执行该命令时，Python 会调用 `hello_python.main` 模块中的 `main` 函数。

这种方式的好处在于：

* 不需要手动编写平台相关的启动脚本；
* Windows、macOS、Linux 行为一致；
* CLI 本身成为项目接口的一部分。

### 打包为独立可执行文件的取舍

在某些面向非开发者的场景中，要求用户事先安装 Python 并配置环境并不现实。这时，可以考虑将项目进一步打包为独立可执行文件。

需要注意的是，这类方案通常：

* 构建体积较大；
* 构建流程更复杂；
* 与平台强绑定。

因此，从工程视角来看，它们更适合作为**交付层解决方案**，而不是开发阶段的默认选择。

在实际项目中，推荐优先采用：

> **“标准 Python 包 + 清晰依赖声明”**

只有在明确的交付需求出现时，再引入额外的可执行打包工具。

### 从工程角度理解“打包”的意义

将项目打包，并不仅仅是为了发布，更重要的是它带来的工程约束：

* 项目必须拥有清晰的入口；
* 元数据必须完整且一致；
* 构建过程必须是可重复的。

这些约束反过来，会倒逼项目在设计阶段就保持良好的结构与边界。

### 本篇小结

在这一篇笔记中，我们完成了从“会写 Python 代码”到“能交付 Python 项目”的过渡：

* 通过 PEP 规范约束项目结构与编码风格；
* 通过虚拟环境与 uv 管理依赖；
* 通过标准化打包流程实现可复现的构建与分发。

从这一刻开始，Python 不再只是脚本语言，而成为了一种**可以被工程化、产品化的开发工具**。

<!-- 以下为待整理资料

上述设计准则会确保程序员们在使用这门语言时自觉地拒绝花俏的语法，并尽可能地使用明确且没有歧义的表达方式来编写代码。当然了，凡事都有两面性，对于这些准则的坚守也让 Python 社区对于牺牲了优雅特性的优化策略始终持有较为谨慎的态度，这导致许多开发者对 Python 语言的一些非重要部分所做的性能优化，和非核心功能的扩展往往很难被其官方直接纳入到其标准库中，某种程度上也限制这门语言在某些特定领域中的运用。而如果想要在这些特定领域中使用 Python 语言进行开发，我们就必须自己手动引入第三方开发的扩展。

在基于 Python 编程工作中，引入第三方扩展最简单的方法就是使用一款叫做 pip 的包管理工具。这是一款 Python 官方提供的扩展包下载与管理工具，可用于查找、下载、安装、卸载所有可引入到 Python 应用中的第三方扩展。在本章的最后，我们就来具体介绍一下 pip 的使用方法。

首先要做的是安装 pip 包管理器。事实上，如果读者安装的是 Python 2.7.9 或 Python 3.4 以上版本的运行时环境，那么在该运行时环境被安装的同时就已经安装 pip 这个包管理器了。对此，我们可以通过在终端环境中执行`pip --version`命令来验证它是否可用，如果该命令输出了正常的版本信息，就证明该包管理器已经可以正常使用了。而如果该命令输出的是找不到 pip 之类的错误信息，那么就需要在终端环境中执行以下命令来安装这个包管理器。

```bash
# 先下载安装脚本
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
# 然后再执行安装脚本
python get-pip.py
```

另外，在部分 Linux 发行版中，我们也可以直接使用操作系统的包管理器来安装 pip，例如在 Ubuntu 系统中，我们只需直接执行`sudo apt install python-pip`命令即可。在确认了 pip 已经被正确安装之后，我们就可以使用这个包管理器来安装并管理 Python 的第三方扩展了，以下是它的一些常用的命令。

- `pip --version`命令：用于查看当前所用 pip 的版本及其安装路径；
- `pip --help`命令：用于获取 pip 的官方帮助信息，这些信息对于初学者是非常有用的；
- `pip config`命令：用于对 pip 本身进行各种配置工作。例如在默认情况下，我们使用该包管理器安装第三方扩展时需要从其官方提供的服务器上下载它们，而该服务器通常位于国外，它的下载速度通常会相对较慢且不稳定，这时候，我们就可以提供执行`pip config set global.index-url [某国内镜像的 URL]`命令将其默认的远程服务器配置成某个指定的国内镜像服务器；
- `pip list`命令：用于列出当前计算机设备中已经安装的第三方扩展；
- `pip search  [扩展包名称]`命令：用于在远程服务器上搜索可用的第三方扩展；
- `pip show [扩展包名称]`命令：用于查看指定第三方扩展的具体信息；
- `pip install [扩展包名称]`命令：用于从远程服务器上下载并安装指定的第三方扩展。该命令默认安装的是最新版本，如果需要安装特定的版本，就需要在安装时指定版本号，例如`pip install Django==1.7`命令安装的就是`1.7`版本的 Django 框架；
- `pip install --upgrade [扩展包名称]`命令：用于更新当前计算机设备中指定的第三方扩展。该命令默认会将扩展包升级到最新版本，如果需要审计到特定的版本，就需要在安装时指定版本号，例如`pip install --upgrade Django==1.8`命令就会将 Django 框架升级到`1.8`的版本；
- `pip uninstall [扩展包名称]`命令：用于从当前计算机设备中删除指定的第三方扩展；

在安装了指定的第三方扩展之后，我们在大多数情况下就可以像使用标准库使用它们了。下面，让我们借助引入并使用`numpy`这个第三方扩展的过程来为读者做一个演示。

1. 在终端环境中执行`pip install numpy`命令将这个名为`numpy`的第三方扩展安装到当前计算机设备中。

2. 待安装过程结束之后，继续在之前创建的`HelloPython`目录下创建一个名为的`exNumpy.py`文件，并在其中输入如下代码。

    ```python
    import numpy;

    # 基于列表对象生成一维数组
    listObj = [1,2,3,4,5,6]
    arr = numpy.array(listObj)
    print("数组中的数据：\n", arr)
    print("数组元素的类型：\n",arr.dtype)

    # 基于列表对象生成二维数组
    listObj = [[1,2],[3,4],[5,6]]
    arr = np.array(listObj)
    print("数组中的数据：\n", arr) 
    print("数组的维度：\n", arr.ndim) 
    print("数组中各维度的长度：\n", arr.shape)  # shape 是一个元组

    arr = np.zeros(6)
    print("创建长度为 6，元素都是 0 的一维数组：\n", arr) 
    arr = np.zeros((2,3)) 
    print("创建 2x3，元素都是 0 的二维数组：\n", arr) 
    arr = np.ones((2,3))
    print("创建 2x3，元素都是 1 的二维数组：\n", arr) 
    arr = np.empty((3,3))
    print("创建 2x3，元素未经初始化的二维数组：\n", arr) 
    ```

3. 在终端环境中进入到`01_HelloPython`目录下，并执行`python exNumpy.py`命令，如果该命令返回如下信息，就证明我们已经成功引入并使用了`numpy`这个第三方扩展。

    ```bash
    数组中的数据：
    [1 2 3 4 5 6]
    数组元素的类型：
    int32
    数组中的数据：
    [[1 2]
    [3 4]
    [5 6]]
    数组的维度：
    2
    数组中各维度的长度：
    (3, 2)
    创建长度为 6，元素都是 0 的一维数组：
    [0. 0. 0. 0. 0. 0.]
    创建 2x3，元素都是 0 的二维数组：
    [[0. 0. 0.]
    [0. 0. 0.]]
    创建 2x3，元素都是 1 的二维数组：
    [[1. 1. 1.]
    [1. 1. 1.]]
    创建 2x3，元素未经初始化的二维数组：
    [[ 0.00000000e+000  0.00000000e+000  0.00000000e+000]
    [ 0.00000000e+000  0.00000000e+000  2.82605549e-321]
    [ 4.53801547e+279 -1.42873560e-101  4.94065646e-324]]
    ```

## 关联笔记索引

- **自动化测试框架**：
  - [[Pytest+Jenkins 学习笔记]]
  - [[Robot 框架学习笔记]]
  - [[Selenium 学习笔记]]
 -->