# Python 3.x 速查手册（活页本）

以下是模拟Python速查手册的文字稿，我初步设计将该手册划分为十个活页，每页都设置有一个独立的主题，各个活页之间用分隔线（即`---`）隔开。

---

## 活页01：基础语法速览

### 缩进规则

> **Python 使用缩进表示代码块，而非花括号 `{}`**

#### 基本规则

* **推荐缩进：4 个空格**
* 同一代码块 **缩进必须一致**
* 不允许混用 Tab 与空格

#### 代码示例

```python
if x > 0:
    print("positive")
    if x > 10:
        print("large")
```

#### 常见错误

* ❌️ 缩进层级不一致
* ❌️ Tab 与空格混用
* ❌️ 在不需要代码块的地方缩进

### 注释方式

#### 单行注释

```python
# 这是单行注释
```

#### 行内注释

```python
x = 10  # 初始化变量
```

#### 文档字符串

```python
def add(a, b):
    """返回 a 与 b 的和"""
    return a + b
```

> 📌 文档字符串（Docstring） 可被 `help()` 和 IDE 识别
> 📌 使用三引号 `""" """`

### 代码块结构

#### 常见代码块起始关键字

* `if / elif / else`
* `for / while`
* `def`
* `class`
* `try / except / finally`
* `with`

#### 统一结构

```python
关键字 条件:
    代码块
```

### Python 语言结构概览

```bash
脚本（script）
│
├─ 模块（module）  →  .py 文件
│
└─ 包（package）   →  用于组织模块的目录（__init__.py 可选）
```

**表 1-1** 对照速览

| 结构 | 说明                        |
| ---- | --------------------------- |
| 脚本 | 直接运行的 Python 文件      |
| 模块 | 可被 import 的 .py 文件     |
| 包   | 组织模块的目录结构          |

### 保留字/关键字速览（按功能分类）

> **关键字不能作为变量名、函数名或类名**

#### 逻辑与控制

```python
if  elif  else  for  while  break  continue  pass
```

#### 函数与类

```python
def  return  lambda  class  yield
```

#### 异常与上下文

```python
try  except  finally  raise  with  as
```

#### 逻辑运算

```python
and  or  not  in  is
```

#### 作用域与导入

```python
import  from  global  nonlocal
```

#### 常量与特殊值

```python
True  False  None
```

> [!TIP] 速查提示
>
> * ❗ 缩进错误是 **SyntaxError** 的常见来源
> * ❗ 关键字大小写敏感（`True` ≠ `true`）
> * ✅️ 推荐使用编辑器自动缩进与语法高亮

---

## 活页02：变量与命名规则

### 命名规范（PEP 8）

> **命名的目标是“可读性优先”，而不是“省字符”**

#### 基本约定

| 对象类型    | 命名形式         | 示例              |
| ----------- | ---------------- | ----------------- |
| 变量 / 函数 | `snake_case`     | `total_count`     |
| 常量        | `UPPER_CASE`     | `MAX_SIZE`        |
| 类          | `PascalCase`     | `UserAccount`     |
| 模块        | `snake_case`     | `math_utils.py`   |
| 包          | 小写             | `utils`           |

#### 不推荐写法

* ❌️ 使用拼音或无意义缩写
* ❌️ 单字符变量名（循环计数器除外）
* ❌️ 与内置名称冲突（如 `list`, `str`）

### 变量绑定与动态类型

> **Python 中变量是“名字”，不是“盒子”**

#### 变量绑定示意

```text
x  ──▶  对象（object）  ──▶  类型（type）
```

```python
x = 10        # x 绑定到 int 对象
x = "hello"   # x 重新绑定到 str 对象
```

* 变量本身 **不保存类型**
* 类型属于对象，而非变量名

### 作用域规则（LEGB）

> **查找变量名的顺序**

```text
Local  ──▶  Enclosing  ──▶  Global  ──▶  Built-in
```

#### 示例

```python
x = 1

def outer():
    x = 2
    def inner():
        print(x)
    inner()
```

输出：

```text
2
```

### global 与 nonlocal

#### global

```python
count = 0

def inc():
    global count
    count += 1
```

* 修改模块级变量
* 不影响内置作用域

#### nonlocal

```python
def outer():
    x = 0
    def inner():
        nonlocal x
        x += 1
```

* 修改外层函数变量
* 仅用于嵌套函数

### 常见命名错误

* ❌️ 覆盖内置名称

  ```python
  list = [1, 2, 3]
  ```

* ❌️ 在不同作用域中滥用同名变量
* ❌️ 使用未定义变量（NameError）

> [!TIP] 速查提示
>
> * ❗ 变量必须先绑定后使用
> * ❗ `global` / `nonlocal` 是**作用域声明**，不是赋值
> * ✅️ 推荐使用 `isinstance()` 进行类型判断

---

## 活页03：内置数据类型速查

### 数值类型

#### `int`

```python
a = 10
b = -3
c = 0
```

* 任意精度（无溢出）
* 支持二进制 / 八进制 / 十六进制表示

```python
0b1010   # 10
0o12     # 10
0xA      # 10
```

#### `float`

```python
x = 3.14
y = 1e-3
```

* 基于 IEEE 754
* 存在精度误差

```python
0.1 + 0.2 == 0.3   # False
```

#### `complex`

```python
z = 1 + 2j
```

* `j` 表示虚部
* 常用于科学计算

### 布尔类型

#### `bool`

```python
True
False
```

* 仅有两个值
* 结果来自比较或逻辑运算

```python
x > 0
a == b
```

#### `bool`与`int`的关系

> **`bool`是`int`的子类**

```python
isinstance(True, int)   # True
```

```python
True == 1    # True
False == 0   # True
```

* 可参与算术运算
* 不推荐依赖该行为进行逻辑判断

### 文本类型

#### `str`

```python
s1 = "hello"
s2 = 'world'
s3 = """多行字符串"""
```

* 不可变（immutable）
* 基于 Unicode

```python
len("你好")   # 2
```

### 空值类型

#### `None`

```python
x = None
```

* 表示“无值”或“未设置”
* 唯一实例

```python
x is None    # 推荐
```

❌️ 不推荐：

```python
x == None
```

### 类型检查与转换

#### 查看类型

```python
type(x)
isinstance(x, int)
```

#### 常见类型转换

```python
int("10")
float("3.14")
str(123)
bool(0)
```

⚠️ 转换失败会抛出 `ValueError`

### 真值判断

> **以下值在布尔上下文中为 False**

```text
False
None
0
0.0
0j
""  (空字符串)
[]  {}  set()
```

其余对象默认为 True

> [!TIP] 速查提示
>
> * ❗ `None` 不是 `0`，也不是 `False`
> * ❗ 浮点数比较应使用容差（如 `math.isclose`）
> * ✅️ 判断“是否为 None”使用 `is`

---

## 活页04：核心数据结构对照表

### 四大内置容器总览

**表 4-1**｜list / tuple / set / dict 对照

| 类型    | 是否有序   | 是否可变 | 是否可重复 | 典型用途                   |
| ------- | ---------- | -------- | ---------- | -------------------------- |
| `list`  | ✅️         | ✅️       | ✅️         | 顺序数据、可修改集合       |
| `tuple` | ✅️         | ❌️       | ✅️         | 不可变记录、函数返回值     |
| `set`   | ❌️         | ✅️       | ❌️         | 去重、集合运算             |
| `dict`  | ✅️（3.7+） | ✅️       | 键不可重复 | 键值映射、结构化数据       |

> 📌 `dict` 在 Python 3.7+ 中**保持插入顺序**

### `list`

```python
lst = [1, 2, 3]
```

#### 常用方法

```python
lst.append(x)
lst.extend(iterable)
lst.insert(i, x)
lst.pop()
lst.remove(x)
lst.sort()
lst.reverse()
```

* 支持索引与切片
* 适合频繁修改

### `tuple`

```python
t = (1, 2, 3)
```

```python
t = 1, 2, 3    # 打包
a, b, c = t    # 解包
```

* 不可变
* 可作为 `dict` 的键

```python
d = {(1, 2): "point"}
```

### `set`

```python
s = {1, 2, 3}
```

* 无序
* 元素必须可哈希

#### 常用集合运算

```python
a | b    # 并集
a & b    # 交集
a - b    # 差集
a ^ b    # 对称差集
```

### `dict`

```python
d = {"a": 1, "b": 2}
```

#### 常用字典方法

```python
d.get(key, default)
d.keys()
d.values()
d.items()
d.pop(key)
d.update(other)
```

#### 遍历模板

```python
for k, v in d.items():
    ...
```

### 可变性对比（重点）

```python
lst[0] = 10        # ✅️
t[0] = 10          # ❌️ TypeError
```

```python
s.add(4)           # ✅️
d["c"] = 3         # ✅️
```

> ⚠️ **可变对象作为函数默认参数是常见陷阱**

### 类型注解中的常见写法（Python 3.9+）

```python
list[int]
tuple[str, int]
set[str]
dict[str, int]
```

#### Python 3.8 及之前

```python
from typing import List, Dict

List[int]
Dict[str, int]
```

> [!TIP] 速查提示
>
> * ❗ `[]` ≠ `{}`（后者是空字典）
> * ✅️ 需要顺序 + 可修改 → `list`
> * ✅️ 需要不可变记录 → `tuple`
> * ✅️ 需要去重 / 成员测试 → `set`
> * ✅️ 需要键值映射 → `dict`

---

## 活页05：条件与循环模板

### 条件判断：`if / elif / else`

#### 基本模板

```python
if condition:
    ...
elif other_condition:
    ...
else:
    ...
```

* 条件表达式为 **布尔上下文**
* 无需括号 `()`

### 布尔上下文

以下值在条件判断中为 `False`：

```python
False
None
0
0.0
""
[]
()
{}
set()
```

> 📌 **非空对象默认视为 True**

### 链式比较

```python
0 < x < 10
```

等价于：

```python
0 < x and x < 10
```

### `for` 循环

#### 基本循环

```python
for item in iterable:
    ...
```

#### 常见搭配

```python
for i in range(5):
    ...
```

```python
for i, v in enumerate(seq):
    ...
```

```python
for a, b in zip(xs, ys):
    ...
```

### `while` 循环

```python
while condition:
    ...
```

* 条件为 `False` 时退出
* 易出现死循环

```python
while True:
    if done:
        break
```

### 循环控制语句

```python
break      # 跳出循环
continue   # 跳过本次
pass       # 占位，不做任何事
```

### `for – else`

```python
for x in data:
    if x == target:
        break
else:
    print("not found")
```

* `else` **只在未触发 break 时执行**
* 常用于查找逻辑

### 条件表达式（三元表达式）

```python
result = a if cond else b
```

### 常见错误对照

```python
if x = 1:        # ❌️ 赋值
```

```python
if x == 1:       # ✅️ 比较
```

```python
if x is 1:       # ❌️
```

```python
if x == 1:       # ✅️
```

> 📌 `is` 用于对象身份判断，不用于数值比较

> [!TIP] 速查提示
>
> * ✅️ 优先使用 `for`，其次 `while`
> * ✅️ 使用 `enumerate` 代替 `range(len())`
> * ❗ `break` 会影响 `for-else` 行为
> * ❗ 注意缩进层级，避免逻辑错位

---

## 活页06：函数与参数机制

### 函数定义（`def`）

```python
def func(a, b):
    return a + b
```

* 使用 `return` 返回结果
* 未显式 `return` → 返回 `None`

### 参数类型总览（从左到右）

```python
def f(pos, /, std, default=1, *args, kw, **kwargs):
    ...
```

| 参数类型       | 示例        | 说明                |
| -------------- | ----------- | ------------------- |
| 位置专用       | `pos, /`    | 只能按位置传参      |
| 位置 / 关键字  | `std`       | 最常见              |
| 默认参数       | `default=1` | 调用时可省略        |
| 可变位置参数   | `*args`     | 接收多余位置参数    |
| 仅关键字参数   | `kw`        | 必须用 `kw=...`     |
| 可变关键字参数 | `**kwargs`  | 接收多余关键字参数  |

> 📌 `/`（位置专用）自 Python 3.8 引入

### 默认参数陷阱（重点）

```python
def bad(x, lst=[]):      # ❌️
    lst.append(x)
    return lst
```

```python
def good(x, lst=None):   # ✅️
    if lst is None:
        lst = []
    lst.append(x)
    return lst
```

### 参数解包（调用时）

```python
args = (1, 2)
kwargs = {"c": 3}

f(*args, **kwargs)
```

### 返回多个值（实为元组）

```python
def divmod(a, b):
    return a // b, a % b
```

```python
q, r = divmod(7, 3)
```

### 类型提示（Python 3.5+）

```python
def add(a: int, b: int) -> int:
    return a + b
```

* **不会在运行期强制检查**
* 供 IDE / 类型检查器使用

### 常见类型注解示例

```python
def f(xs: list[int]) -> dict[str, int]:
    ...
```

```python
from typing import Optional

def g(x: Optional[int]) -> int:
    ...
```

### 联合类型（Union）

#### 传统写法（≤ 3.9）

```python
from typing import Union

def f(x: Union[int, str]):
    ...
```

#### 新写法（3.10+）

```python
def f(x: int | str):
    ...
```

### 可调用对象

```python
from collections.abc import Callable

def apply(f: Callable[[int], int], x: int) -> int:
    return f(x)
```

> [!TIP] 速查提示
>
> * ❗ 默认参数只在**定义时**求值
> * ✅️ 返回多个值本质是 `tuple`
> * ✅️ 使用类型提示提高可读性
> * ❗ 类型注解 ≠ 运行时检查

## 活页07：模块、包与导入规则

### 模块

> **一个 `.py` 文件就是一个模块**

```python
import math
math.sqrt(4)
```

```python
from math import sqrt
sqrt(4)
```

### 常见导入形式对照

| 写法              | 说明         | 建议        |
| ----------------- | ------------ | ----------- |
| `import m`        | 导入整个模块 | ✅️ 推荐     |
| `import m as x`   | 模块别名     | ✅️ 常用     |
| `from m import f` | 导入成员     | ⚠️ 谨慎     |
| `from m import *` | 全量导入     | ❌️ 不推荐   |

### 模块搜索路径（`sys.path`）

```python
import sys
sys.path
```

搜索顺序（简化）：

1. 当前脚本目录
2. `PYTHONPATH`
3. 标准库
4. site-packages

> 📌 导入失败通常是 **路径问题**

### 包

> **包是组织模块的目录**

```text
mypkg/
│
├─ __init__.py
├─ a.py
└─ b.py
```

```python
from mypkg import a
from mypkg.b import func
```

* Python 3.3+ 支持 **隐式命名空间包**
* 但工程中仍推荐保留 `__init__.py`

### `__name__ == "__main__"`

```python
if __name__ == "__main__":
    main()
```

| 场景     | `__name__`   |
| -------- | ------------ |
| 直接运行 | `"__main__"` |
| 被导入   | 模块名       |

> 📌 用于区分 **脚本入口** 与 **可复用模块**

### 相对导入（包内）

```python
from . import a
from ..utils import helper
```

* 只能在包内使用
* 不能直接运行包含相对导入的模块

### 导入顺序（PEP 8）

```python
# 1. 标准库
import os
import sys

# 2. 第三方库
import requests

# 3. 本地模块
from . import utils
```

### 常见导入错误

```python
ImportError
ModuleNotFoundError
```

常见原因：

* 模块名与文件名冲突
* 运行路径不正确
* 相对导入误用

> [!TIP] 速查提示
>
> * ✅️ 优先使用 `import module`
> * ❗ 避免 `import *`
> * ✅️ 工程结构比技巧更重要
> * ❗ 模块名不要与标准库重名（如 `random.py`）

---

## 活页08：异常处理速查

### 基本结构：`try / except / else / finally`

```python
try:
    risky()
except ValueError:
    handle()
else:
    success()
finally:
    cleanup()
```

| 块        | 何时执行     |
| --------- | ------------ |
| `try`     | 正常执行代码 |
| `except`  | 捕获异常     |
| `else`    | 无异常时执行 |
| `finally` | 无论是否异常 |

### 捕获多个异常

```python
except (TypeError, ValueError):
    ...
```

```python
except Exception as e:
    print(e)
```

> ⚠️ **避免直接捕获 `Exception`（除非边界层）**

### 常见内置异常速览

| 异常                | 触发场景       |
| ------------------- | -------------- |
| `ValueError`        | 值合法但不合适 |
| `TypeError`         | 类型不匹配     |
| `IndexError`        | 下标越界       |
| `KeyError`          | 字典键不存在   |
| `AttributeError`    | 属性不存在     |
| `FileNotFoundError` | 文件不存在     |
| `ZeroDivisionError` | 除零           |

### 主动抛出异常：`raise`

```python
if x < 0:
    raise ValueError("x must be >= 0")
```

### 异常链

```python
try:
    int("x")
except ValueError as e:
    raise RuntimeError("parse failed") from e
```

* 保留原始异常上下文
* 便于调试

### 自定义异常

```python
class MyError(Exception):
    pass
```

```python
raise MyError("something wrong")
```

* 继承自 `Exception`
* 用于表达业务语义

### `finally` 与资源清理

```python
f = open("data.txt")
try:
    ...
finally:
    f.close()
```

> ✅️ 更推荐使用 `with`

### `else` 的典型用法

```python
try:
    x = int(s)
except ValueError:
    return None
else:
    return x
```

* 把 **正常逻辑** 与 **异常处理** 分离

### 常见错误对照

```python
except ValueError:
    pass        # ❌️ 静默吞异常
```

```python
except ValueError as e:
    log(e)      # ✅️ 至少记录
```

> [!TIP] 速查提示
>
> * ✅️ 精确捕获异常类型
> * ❗ 不要用异常做流程控制
> * ✅️ 使用异常表达“异常情况”
> * ❗ `finally` 一定会执行（除非进程终止）

---

## 活页09：文件与上下文管理器

### 打开文件：`open()`

```python
f = open(path, mode="r", encoding="utf-8")
```

#### 常用参数

| 参数       | 说明     |
| ---------- | -------- |
| `path`     | 文件路径 |
| `mode`     | 打开模式 |
| `encoding` | 文本编码 |

### 打开模式对照表

| 模式 | 含义               |
| ---- | ------------------ |
| `r`  | 只读（默认）       |
| `w`  | 写入（清空原内容） |
| `a`  | 追加               |
| `x`  | 新建，存在则失败   |
| `b`  | 二进制模式         |
| `t`  | 文本模式（默认）   |
| `+`  | 读写               |

```python
open("a.txt", "rb")
open("a.txt", "w+", encoding="utf-8")
```

### 读取文件

```python
f.read()
f.readline()
f.readlines()
```

```python
for line in f:
    ...
```

### 写入文件

```python
f.write("hello\n")
f.writelines(lines)
```

> 📌 `write()` 不会自动换行

### 上下文管理器：`with`

```python
with open("a.txt", "r", encoding="utf-8") as f:
    data = f.read()
```

* 自动关闭资源
* 即使发生异常也能清理

### `with` 的本质（简化）

```python
obj.__enter__()
...
obj.__exit__(exc_type, exc, tb)
```

> 📌 任何实现该协议的对象都可用于 `with`

### 文本 vs 二进制（重点）

| 文本模式   | 二进制模式   |
| ---------- | ------------ |
| `str`      | `bytes`      |
| 有编码     | 无编码       |
| 跨平台换行 | 原始字节     |

```python
open("img.png", "rb")
```

### 编码问题速查

* ✅️ 明确指定 `encoding`
* ✅️ 推荐 UTF-8
* ❗ Windows 默认编码可能不同
* ❗ 解码失败 → `UnicodeDecodeError`

### 常见错误对照

```python
f = open("a.txt")
data = f.read()
# 忘记关闭文件 ❌️
```

```python
with open("a.txt") as f:
    data = f.read()   # ✅️
```

> [!TIP] 速查提示
>
> * ✅️ 始终优先使用 `with`
> * ✅️ 文本处理用 `t`，二进制用 `b`
> * ❗ 不要手动混合 `str` 与 `bytes`
> * ❗ 写文件前确认模式是否会覆盖内容

---

## 活页10：常用内置函数与 I/O 速查

### 序列与长度

```python
len(x)
```

* 返回元素个数
* 支持序列、映射、集合

### 数值与范围

```python
range(stop)
range(start, stop, step)
```

* 惰性序列
* 常与 `for` 搭配

### 索引与计数

```python
enumerate(iterable, start=0)
```

```python
for i, v in enumerate(xs):
    ...
```

* 替代 `range(len(xs))`

### 并行遍历

```python
zip(a, b)
```

```python
for x, y in zip(xs, ys):
    ...
```

* 以最短序列为准

### 映射与过滤

```python
map(func, iterable)
filter(func, iterable)
```

* 返回迭代器
* 常被推导式替代

### 排序

```python
sorted(iterable)
sorted(iterable, key=func, reverse=True)
```

```python
lst.sort()   # 原地
```

### 聚合判断

```python
any(iterable)
all(iterable)
```

* `any`：存在 True
* `all`：全部 True

### 控制台输入：`input()`

```python
s = input("Enter value: ")
```

* 返回 `str`
* 需手动转换类型

```python
n = int(input())
```

### 控制台输出：`print()`

```python
print(a, b, sep=", ", end="\n")
```

| 参数   | 作用     |
| ------ | -------- |
| `sep`  | 分隔符   |
| `end`  | 结尾字符 |
| `file` | 输出目标 |

```python
print(msg, file=sys.stderr)
```

### 输出转换与显示

#### 字符串化

```python
str(x)
repr(x)
```

| 函数   | 用途       |
| ------ | ---------- |
| `str`  | 面向用户   |
| `repr` | 面向开发者 |

### 格式化输出

#### `format()`

```python
"{:.2f}".format(3.14159)
```

#### f-string（推荐）

```python
f"{name} = {value:.2f}"
```

* Python 3.6+
* 可直接写表达式

### 常见错误对照

```python
print = 10     # ❌️ 覆盖内置函数
```

```python
n = input() + 1   # ❌️ 类型错误
```

```python
n = int(input()) + 1   # ✅️
```

> [!TIP] 速查提示
>
> * ✅️ 避免覆盖内置函数名
> * ✅️ f-string 是首选格式化方式
> * ❗ `input()` 永远返回字符串
> * ❗ `map / filter` 返回迭代器

---

## 活页11：推导式与生成器

### 列表推导式（List Comprehension）

```python
[x * 2 for x in data]
```

```python
[x for x in data if x > 0]
```

* 更简洁
* 可读性高（适度）

### 字典推导式（Dict Comprehension）

```python
{k: v for k, v in pairs}
```

```python
{k: v for k, v in pairs if v > 0}
```

### 集合推导式（Set Comprehension）

```python
{x for x in data}
```

* 自动去重

### 生成器表达式（Generator Expression）

```python
(x * 2 for x in data)
```

* 返回生成器对象
* **惰性求值**

```python
gen = (x for x in range(10))
next(gen)
```

### 推导式 vs 生成器（核心对比）

| 项目           | 推导式              | 生成器      |
| -------------- | ------------------- | ----------- |
| 返回类型       | `list / dict / set` | `generator` |
| 是否一次性生成 | ✅️                  | ❌️          |
| 内存占用       | 较高                | 低          |
| 是否可复用     | ✅️                  | ❌️（一次）  |

### 多重循环写法

```python
[(x, y) for x in xs for y in ys]
```

等价于：

```python
for x in xs:
    for y in ys:
        ...
```

### 条件组合

```python
[x for x in data if x > 0 if x % 2 == 0]
```

### 生成器函数：`yield`

```python
def count_up(n):
    i = 0
    while i < n:
        yield i
        i += 1
```

```python
for x in count_up(3):
    ...
```

* 每次 `yield` 暂停执行
* 保留函数状态

### `yield` vs `return`

```python
return x   # 结束函数
yield x    # 暂停函数
```

### 常见错误对照

```python
(x for x in data)    # ✅️ 生成器
[x for x in data]    # ✅️ 列表
```

```python
(x for x in data)[0] # ❌️ 不能索引
```

### 使用场景建议

* ✅️ 小数据 + 需要结果 → 推导式
* ✅️ 大数据 / 流式处理 → 生成器
* ❗ 复杂逻辑不要硬塞进推导式

### 速查提示（Quick Tips）

* ✅️ 推导式是表达式，不是语句
* ✅️ 生成器只能遍历一次
* ❗ 可读性优先于“炫技”

---

## 活页12：装饰器与常见高级语法

### 装饰器的本质

> **装饰器 = 接收函数 → 返回新函数的函数**

```python
def deco(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
```

### 基本用法

```python
@deco
def f():
    ...
```

等价于：

```python
f = deco(f)
```

### 保留原函数信息：`functools.wraps`

```python
from functools import wraps

def deco(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
```

* 保留 `__name__`
* 保留 `__doc__`

### 带参数的装饰器

```python
def deco(arg):
    def inner(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    return inner
```

```python
@deco(10)
def f():
    ...
```

### 多个装饰器的执行顺序（重点）

```python
@a
@b
def f():
    ...
```

等价于：

```python
f = a(b(f))
```

* **靠近函数的先执行**

### 常见内置装饰器

```python
@staticmethod
@classmethod
@property
```

| 装饰器          | 用途           |
| --------------- | -------------- |
| `@staticmethod` | 无实例、无类   |
| `@classmethod`  | 接收 `cls`     |
| `@property`     | 属性式访问     |

### 闭包（Closure）

```python
def outer(x):
    def inner():
        return x
    return inner
```

* 捕获外部作用域变量
* 常与装饰器配合

### 上下文管理器（高级用法）

```python
from contextlib import contextmanager

@contextmanager
def ctx():
    ...
    yield
    ...
```

* 用函数方式实现 `with`

### `dataclass`（结构化数据）

```python
from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int
```

* 自动生成 `__init__`
* 自动生成 `__repr__`

### 常见误区对照

```python
@deco
f()     # ❌️ 装饰器修饰函数，不是调用
```

```python
@deco()
def f():    # ⚠️ 只有当 deco 返回装饰器时才合法
```

> [!TIP] 速查提示
>
> * ✅️ 装饰器本质是函数替换
> * ✅️ 永远使用 `@wraps`
> * ❗ 多装饰器注意执行顺序
> * ❗ 不要滥用装饰器增加复杂度

---

<!-- 
以下为参考资料：

https://www.amazon.com/Python-Programming-Language-QuickStudy-Laminated/dp/1423251652

Python Programming Language: a QuickStudy Laminated Reference Guide

为各个技能水平的开发者打造，汇集常见操作的核心要点，并提供编写代码时最快捷的参考指南。这本实用的 **6 页覆膜速查卡** 是一份简明的桌面参考资料，涵盖 Python 逻辑、语法和操作背后的关键概念。内容由专家精心编写，重点讲解使用 Python 进行程序规划、变量的初始赋值、导入其他库、格式化输出字符串以及创建类等内容。无论是初学者还是经验丰富的程序员，都会发现它是查阅核心概念的理想工具。超高的性价比，让你可以轻松将这份参考指南加入程序员的工具箱。

**6 页覆膜速查指南包含：**

* 历史与关键特性
* 语言结构
* 命名规范
* 变量与数据类型
* 常见数据类型
* 类型提示与静态类型（Python 3.5+）
* 联合类型（Unions）
* 保留关键字
* 模块导入
* 控制台输入与输出
* 输出显示
* 输出转换 
-->
